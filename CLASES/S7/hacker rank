import sys
import math

def calculate_euclidean(p1, p2):
    return math.sqrt(sum((a - b)**2 for a, b in zip(p1, p2)))

def get_linkage_dist(cluster_a, cluster_b, dist_matrix, linkage):
    distances = [dist_matrix[i][j] for i in cluster_a for j in cluster_b]
    if linkage == 0:   # Single Linkage (Min)
        return min(distances)
    elif linkage == 1: # Complete Linkage (Max)
        return max(distances)
    else:              # Average Linkage (Mean)
        return sum(distances) / len(distances)

def solve():
    # Lectura de la configuración inicial
    input_data = sys.stdin.read().split()
    if not input_data: return
    
    N, P, K, L = map(int, input_data[:4])
    coords = []
    idx = 4
    for _ in range(N):
        coords.append([float(x) for x in input_data[idx:idx+P]])
        idx += P

    # Precalcular matriz de distancias punto a punto
    dist_matrix = [[0.0]*N for _ in range(N)]
    for i in range(N):
        for j in range(i + 1, N):
            d = calculate_euclidean(coords[i], coords[j])
            dist_matrix[i][j] = dist_matrix[j][i] = d

    # clusters: diccionario de {id: [índices_de_puntos]}
    clusters = {i: [i] for i in range(N)}
    next_id = N
    history = []

    # Proceso de fusión sucesiva
    while len(clusters) > K:
        min_dist = float('inf')
        best_pair = None
        
        current_ids = sorted(clusters.keys())
        
        for i in range(len(current_ids)):
            for j in range(i + 1, len(current_ids)):
                id_a, id_b = current_ids[i], current_ids[j]
                d = get_linkage_dist(clusters[id_a], clusters[id_b], dist_matrix, L)
                
                # Criterio de selección con desempate por ID
                # Usamos un pequeño epsilon para manejar precisión de punto flotante
                if d < min_dist - 1e-9:
                    min_dist = d
                    best_pair = (id_a, id_b)
                elif abs(d - min_dist) < 1e-9:
                    if best_pair is None or id_a < best_pair[0] or (id_a == best_pair[0] and id_b < best_pair[1]):
                        best_pair = (id_a, id_b)

        id_a, id_b = best_pair
        history.append(f"{id_a} {id_b} {next_id} {min_dist:.4f}")
        
        # Crear nuevo cluster y eliminar los antiguos
        clusters[next_id] = clusters[id_a] + clusters[id_b]
        del clusters[id_a]
        del clusters[id_b]
        next_id += 1

    # Imprimir historial de fusiones
    for line in history:
        print(line)

    # Generar etiquetas finales
    # Ordenar los clusters por el índice de punto original más pequeño que contienen
    final_clusters_list = sorted(clusters.values(), key=min)
    point_labels = [0] * N
    
    for label, cluster_points in enumerate(final_clusters_list):
        for p_idx in cluster_points:
            point_labels[p_idx] = label
            
    print(*(point_labels))

if __name__ == "__main__":
    solve()